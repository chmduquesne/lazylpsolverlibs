#!/bin/sh
#
# Copyright 2010-2012 Christophe-Marie Duquesne <chm.duquesne@gmail.com>
#
# This file is part of lazylpsolverlibs
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the Eclipse Public License.
#
# lazylpsolverlibs is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the Eclipse Public License
# along with this program.  If not, see
# <http://www.eclipse.org/legal/epl-v10.html>.

usage()
{
    echo "Usage: sh $0 <solver_name> <std_include_path> <symbol_file> <header_prefix> <cfile_prefix>"
    echo "    solver_name: cplex, gurobi, xprs, glpk"
    echo "    std_include_path: ilcplex/cplex.h, gurobi_c.h, xprs.h, glpk.h"
    echo "    symbol_file: list of symbols to fake"
    echo "    header_prefix: where to generate the header"
    echo "    cfile_prefix: where to generate the c file"
}

exit_error()
{
    echo "$@"
    usage
    exit 1
}

[ -z "$1" ] && exit_error "missing solver name"   || solver_name=$1
[ -z "$2" ] && exit_error "missing include path"  || std_include_path=$2
[ -z "$3" ] && exit_error "missing symbol file"   || symbols=$(cat $3)
[ -z "$4" ] && exit_error "missing header prefix" || header_prefix=$4
[ -z "$5" ] && exit_error "missing cfile prefix"  || cfile_prefix=$5

lazy_header=lazy${solver_name}.h
lazy_cfile=lazy${solver_name}.c
capitalized_name=$(echo ${solver_name} | sed 's/\S/\U&\L/g')

generate_header() {

    echo "/*
     *!/bin/sh
     *
     * Copyright 2010-2012 Christophe-Marie Duquesne <chm.duquesne@gmail.com>
     *
     * This file is part of lazylpsolverlibs
     *
     * This program is free software: you can redistribute it and/or modify
     * it under the terms of the Eclipse Public License.
     *
     * lazylpsolverlibs is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     * GNU General Public License for more details.
     *
     * You should have received a copy of the Eclipse Public License
     * along with this program.  If not, see
     * <http://www.eclipse.org/legal/epl-v10.html>.
     *
     * This file was generated by tools/generate_stub.sh. Do not modify
     * directly
     *
     */"  >> $header_prefix/$lazy_header

    echo "
    #ifndef LAZY_${capitalized_name}_H
    #define LAZY_${capitalized_name}_H

    #include <gmodule.h>
    #include \"lazy_loading_status.h\"

    #ifdef __cplusplus
    extern \"C\" {
    #endif

    #ifdef _WIN32
    #ifdef BUILDING_LAZYLPSOLVERLIBS
    #define LLSL_DECL __declspec(dllexport)
    #else
    #define LLSL_DECL __declspec(dllimport)
    #endif
    #else
    #define LLSL_DECL
    #endif

    /* loads the symbols */
    LLSL_DECL int load_${solver_name}_symbols();
    /* unloads the symbols (if called as many times as loadSymbols) */
    LLSL_DECL int unload_${solver_name}_symbols();
    /* prints what symbols ar missing */
    LLSL_DECL void print_${solver_name}_missing_symbols();
    " >> $header_prefix/$lazy_header


    for i in $symbols; do
        echo "#define $i LLSL_DECL (*__symbolic_$i)" >> $header_prefix/$lazy_header
    done

    echo "
    #ifdef __cplusplus
    }
    #endif

    #include <${std_include_path}>

    #ifdef _WIN32
    /*
     * Windows corner case:
     *
     * Beyond this point, LLSL_DECL, which normally expands as
     * __declspec(dllimport) in order to allow the user to import our dll,
     * must be redefined as nothing: we don't want this macro to propagate
     * in the C files.
     *
     * Obviously this issues a warning, but this should be harmless.
     */
    #undef LLSL_DECL
    #define LLSL_DECL
    #endif

    #endif /* LAZY_${capitalized_name}_H */
    " >> $header_prefix/$lazy_header
    sed -i "s/^    \(.*\)/\1/g" $header_prefix/$lazy_header
}

versioned_library_names() {
    case $solver_name in
        cplex)
            echo "        /* then try some versioned library names known to work (most recent first)*/"
            for i in 121 120 112 111 110 102 101 100 91 90 81 80 75 71 \
                70 66 65 60 50 40 30 21 20; do
                echo "        if (!__cplex_module) __cplex_module = g_module_open_all(\"cplex$i\", G_MODULE_BIND_LAZY);"
            done
            ;;
        gurobi)
            echo "        /* then try some versioned library names known to work (most recent first)*/"
            for i in 461 452 402 303; do
                echo "        if (!__gurobi_module) __gurobi_module = g_module_open_all(\"gurobi$i\", G_MODULE_BIND_LAZY);"
            done
            ;;
    esac
}

generate_c_file() {
    echo "/*
     *!/bin/sh
     *
     * Copyright 2010-2012 Christophe-Marie Duquesne <chm.duquesne@gmail.com>
     *
     * This file is part of lazylpsolverlibs
     *
     * This program is free software: you can redistribute it and/or modify
     * it under the terms of the Eclipse Public License.
     *
     * lazylpsolverlibs is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     * GNU General Public License for more details.
     *
     * You should have received a copy of the Eclipse Public License
     * along with this program.  If not, see
     * <http://www.eclipse.org/legal/epl-v10.html>.
     *
     * This file was generated by tools/generate_stub.sh. Do not modify
     * directly
     *
     */" >> $cfile_prefix/$lazy_cfile
    echo "
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    #include \"$lazy_header\"

    /* handle to the library */
    LLSL_DECL GModule *__${solver_name}_module = NULL;

    GModule *g_module_open_all(const gchar *name, GModuleFlags flags) {
        char *LIB_PATH, *LIB_PATH_COPY, *p, *dir;
        GModule *res;

        p = NULL;
        dir = NULL;
        res = NULL;

    #ifdef _WIN32
        LIB_PATH = getenv(\"PATH\");
    #define PATH_SEP ';'
    #else
        LIB_PATH = getenv(\"LD_LIBRARY_PATH\");
    #define PATH_SEP ':'
    #endif

        res = g_module_open(g_module_build_path(NULL, name), flags);
        if (res) {
            return res;
        }
        if (LIB_PATH) {
            LIB_PATH_COPY = malloc(strlen(LIB_PATH));
            strncpy(LIB_PATH_COPY, LIB_PATH, strlen(LIB_PATH));
            p = LIB_PATH_COPY;
            dir = p;
            while ((p = strchr(p, PATH_SEP))) {
                *p = '\\\0';
                p++;
                res = g_module_open(g_module_build_path(dir, name), flags);
                if (res) {
                    free(LIB_PATH_COPY);
                    return res;
                }
                dir = p;
            }
            res = g_module_open(g_module_build_path(dir, name), flags);
            free(LIB_PATH_COPY);
        }

        return res;
    }

    int load_${solver_name}_symbols() {
        int res;
        char *LAZYLPSOLVERLIBS_${capitalized_name}_LIB_PATH; /* environment variable */
        LAZYLPSOLVERLIBS_${capitalized_name}_LIB_PATH = NULL;

        /* first, try to read the path to load from the environment */
        LAZYLPSOLVERLIBS_${capitalized_name}_LIB_PATH = getenv(\"LAZYLPSOLVERLIBS_${capitalized_name}_LIB_PATH\");
        if (LAZYLPSOLVERLIBS_${capitalized_name}_LIB_PATH != NULL) {
            __${solver_name}_module = g_module_open(LAZYLPSOLVERLIBS_${capitalized_name}_LIB_PATH, G_MODULE_BIND_LAZY);
        }

        /* if this failed, try to load libraries without version number */
        if (!__${solver_name}_module) __${solver_name}_module = g_module_open_all(\"${solver_name}\", G_MODULE_BIND_LAZY);
    " >> $cfile_prefix/$lazy_cfile
    versioned_library_names >> $cfile_prefix/$lazy_cfile
    echo "
        /* if everything failed, give up */
        if (!__${solver_name}_module) return SYMBOL_LOAD_FAIL;

        res = SYMBOL_LOAD_SUCCESS;
    " >> $cfile_prefix/$lazy_cfile
    for i in $symbols; do
        echo "        if (!g_module_symbol(__${solver_name}_module, \"$i\", (gpointer *) &__symbolic_$i)) res = SYMBOL_MISSING;" >> $cfile_prefix/$lazy_cfile
    done
    echo "
        return res;
    }

    void print_${solver_name}_missing_symbols() {
    " >> $cfile_prefix/${lazy_cfile}
    for i in $symbols; do
        echo "        if (!__symbolic_$i) printf(\"$i\\\n\");" >> $cfile_prefix/$lazy_cfile
    done
    echo "
    }

    int unload_${solver_name}_symbols() {
        /* unload library */
        if (!g_module_close (__${solver_name}_module)) return SYMBOL_UNLOAD_FAIL;
        __${solver_name}_module = NULL;

        return SYMBOL_UNLOAD_SUCCESS;
    }
    " >> $cfile_prefix/$lazy_cfile
    sed -i "s/^    \(.*\)/\1/g" $cfile_prefix/$lazy_cfile
}

rm -f $header_prefix/$lazy_header $cfile_prefix/$lazy_cfile
generate_header
generate_c_file
