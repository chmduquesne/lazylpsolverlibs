#!/bin/sh

usage()
{
    echo "Usage: sh $0 <solver_name> <std_include_path> <symbol_file> <header_prefix> <cfile_prefix>"
    echo "    solver_name: cplex, gurobi, xprs, glpk"
    echo "    std_include_path: ilcplex/cplex.h, gurobi_c.h, xprs.h, glpk.h"
    echo "    symbol_file: list of symbols to fake"
    echo "    header_prefix: where to generate the header"
    echo "    cfile_prefix: where to generate the c file"
}

exit_error()
{
    echo "$@"
    usage
    exit 1
}

[ -z "$1" ] && exit_error "missing solver name"   || solver_name=$1
[ -z "$2" ] && exit_error "missing include path"  || std_include_path=$2
[ -z "$3" ] && exit_error "missing symbol file"   || symbols=$(cat $3)
[ -z "$4" ] && exit_error "missing header prefix" || header_prefix=$4
[ -z "$5" ] && exit_error "missing cfile prefix"  || cfile_prefix=$5

lazy_header=lazy${solver_name}.h
lazy_cfile=lazy${solver_name}.c
capitalized_name=$(echo ${solver_name} | sed 's/\S/\U&\L/g')

generate_header() {

    echo "/* This file was generated by tools/generate_stub.sh. Do not modify directly */ " >> $header_prefix/$lazy_header
    echo "
    #ifndef LAZY_${capitalized_name}_H
    #define LAZY_${capitalized_name}_H

    #include <gmodule.h>
    #include \"lazy_loading_status.h\"

    #ifdef __cplusplus
    extern \"C\" {
    #endif

    #ifdef _WIN32
    #ifdef BUILDING_LAZYLPSOLVERLIBS
    #define LLSL_DECL __declspec(dllexport)
    #else
    #define LLSL_DECL __declspec(dllimport)
    #endif
    #else
    #define LLSL_DECL
    #endif

    /* handle to the library */
    LLSL_DECL GModule *__${solver_name}_module;
    /* loads the symbols */
    LLSL_DECL int load_${solver_name}_symbols();
    /* unloads the symbols (if called as many times as loadSymbols) */
    LLSL_DECL int unload_${solver_name}_symbols();
    /* prints what symbols ar missing */
    LLSL_DECL void print_${solver_name}_missing_symbols();
    " >> $header_prefix/$lazy_header


    for i in $symbols; do
        echo "#define $i LLSL_DECL (*__symbolic_$i)" >> $header_prefix/$lazy_header
    done

    echo "
    #ifdef __cplusplus
    }
    #endif

    #include <${std_include_path}>

    #ifdef _WIN32
    /*
     * Windows corner case:
     *
     * Beyond this point, LLSL_DECL, which normally expands as
     * __declspec(dllimport) in order to allow the user to import our dll,
     * must be redefined as nothing: we don't want this macro to propagate
     * in the C files.
     *
     * Obviously this issues a warning, but this should be harmless.
     */
    #undef LLSL_DECL
    #define LLSL_DECL
    #endif

    #endif /* LAZY_${capitalized_name}_H */
    " >> $header_prefix/$lazy_header
    sed -i "s/^    \(.*\)/\1/g" $header_prefix/$lazy_header
}

versioned_library_names() {
    case $solver_name in
        cplex)
            echo "        /* then try some versioned library names known to work (most recent first)*/"
            for i in 121 120 112 111 110 102 101 100 91 90 81 80 75 71 \
                70 66 65 60 50 40 30 21 20; do
                echo "        if (!__cplex_module) __cplex_module = g_module_open(g_module_build_path(NULL, \"cplex$i\"), G_MODULE_BIND_LAZY);"
            done
            ;;
        gurobi)
            echo "        /* then try some versioned library names known to work (most recent first)*/"
            for i in 461 452 402 303; do
                echo "        if (!__gurobi_module) __gurobi_module = g_module_open(g_module_build_path(NULL, \"gurobi$i\"), G_MODULE_BIND_LAZY);"
            done
            ;;
    esac
}

generate_c_file() {
    echo "/* This file was generated by tools/generate_stub.sh. Do not modify directly */ " >> $cfile_prefix/$lazy_cfile
    echo "
    #include <stdio.h>
    #include <stdlib.h>
    #include \"$lazy_header\"

    int load_${solver_name}_symbols() {
        int res;
        char *LAZYLPSOLVERLIBS_${capitalized_name}_LIB_PATH; /* environment variable */
        LAZYLPSOLVERLIBS_${capitalized_name}_LIB_PATH = NULL;
        __${solver_name}_module = NULL;

        /* first, try to read the path to load from the environment */
        LAZYLPSOLVERLIBS_${capitalized_name}_LIB_PATH = getenv(\"LAZYLPSOLVERLIBS_${capitalized_name}_LIB_PATH\");
        if (LAZYLPSOLVERLIBS_${capitalized_name}_LIB_PATH != NULL) {
            __${solver_name}_module = g_module_open(LAZYLPSOLVERLIBS_${capitalized_name}_LIB_PATH, G_MODULE_BIND_LAZY);
        }

        /* if this failed, try to load libraries without version number */
        if (!__${solver_name}_module) __${solver_name}_module = g_module_open(g_module_build_path(NULL, \"${solver_name}\"), G_MODULE_BIND_LAZY);
    " >> $cfile_prefix/$lazy_cfile
    versioned_library_names >> $cfile_prefix/$lazy_cfile
    echo "
        /* if everything failed, give up */
        if (!__${solver_name}_module) return SYMBOL_LOAD_FAIL;

        res = SYMBOL_LOAD_SUCCESS;
    " >> $cfile_prefix/$lazy_cfile
    for i in $symbols; do
        echo "        if (!g_module_symbol(__${solver_name}_module, \"$i\", (gpointer *) &__symbolic_$i)) res = SYMBOL_MISSING;" >> $cfile_prefix/$lazy_cfile
    done
    echo "
        return res;
    }

    void print_${solver_name}_missing_symbols() {
    " >> $cfile_prefix/${lazy_cfile}
    for i in $symbols; do
        echo "        if (!__symbolic_$i) printf(\"$i\\\n\");" >> $cfile_prefix/$lazy_cfile
    done
    echo "
    }

    int unload_${solver_name}_symbols() {
        /* unload library */
        if (!g_module_close (__${solver_name}_module)) return SYMBOL_UNLOAD_FAIL;

        return SYMBOL_UNLOAD_SUCCESS;
    }
    " >> $cfile_prefix/$lazy_cfile
    sed -i "s/^    \(.*\)/\1/g" $cfile_prefix/$lazy_cfile
}

rm -f $header_prefix/$lazy_header $cfile_prefix/$lazy_cfile
generate_header
generate_c_file
